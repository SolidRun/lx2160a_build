From a185ff883ab8e3d2823590e73b7b000f470f02a2 Mon Sep 17 00:00:00 2001
From: Josua Mayer <josua@solid-run.com>
Date: Tue, 31 Dec 2024 15:39:17 +0100
Subject: [PATCH] net: phy: ds250dfx10: add support for 1Gbps SGMII data rate

The DS250DFx10 retimers support a wide range of data rates, from
1.25Gbps to 25.8.

Add support for 1.25Gbps SGMII rate using the manual override registers.

Signed-off-by: Josua Mayer <josua@solid-run.com>
---
 drivers/phy/ti/phy-ti-ds250dfx10.c | 80 ++++++++++++++++++++++++++++++
 1 file changed, 80 insertions(+)

diff --git a/drivers/phy/ti/phy-ti-ds250dfx10.c b/drivers/phy/ti/phy-ti-ds250dfx10.c
index bfbbf35c430c..0ba6a1417533 100644
--- a/drivers/phy/ti/phy-ti-ds250dfx10.c
+++ b/drivers/phy/ti/phy-ti-ds250dfx10.c
@@ -71,6 +71,59 @@ static int ds250dfx10_write_register(struct i2c_client *client, uint8_t address,
 	return 0;
 }
 
+static void ds250dfx10_config_1g(struct i2c_client *client, uint8_t channel)
+{
+	int ret = 0;
+
+	// enable smbus access to single channel
+	ret |= ds250dfx10_write_register(client, 0xFF, 0x01, 0x03);
+
+	// select channel
+	ret |= ds250dfx10_write_register(client, 0xFC, 1 << channel, 0xFF);
+
+	// reset channel registers
+	ret |= ds250dfx10_write_register(client, 0x00, 0x04, 0x04);
+
+	// assert cdr
+	ret |= ds250dfx10_write_register(client, 0x0A, 0x0C, 0x0C);
+
+	// set manual data rate override to 1.25Gbps
+	ret |= ds250dfx10_write_register(client, 0x60, 0x00, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x61, 0xb2, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x62, 0x00, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x63, 0xb2, 0xFF);
+
+	// set maximum ppm delta tolerance
+	ret |= ds250dfx10_write_register(client, 0x64, 0xFF, 0xFF);
+
+	// enable manual divider override
+	ret |= ds250dfx10_write_register(client, 0x09, 0x04, 0x04);
+
+	// set divider to 16
+	ret |= ds250dfx10_write_register(client, 0x18, 0x40, 0x70);
+
+	// enable pre- and post-fir
+	ret |= ds250dfx10_write_register(client, 0x3D, 0x80, 0x80);
+
+	// set main cursor magnitude +15
+	ret |= ds250dfx10_write_register(client, 0x3D, 0x00, 0x40);
+	ret |= ds250dfx10_write_register(client, 0x3D, 0x0F, 0x1F);
+
+	// set pre cursor magnitude -4
+	ret |= ds250dfx10_write_register(client, 0x3E, 0x40, 0x40);
+	ret |= ds250dfx10_write_register(client, 0x3E, 0x04, 0x0F);
+
+	// set post cursor magnitude -4
+	ret |= ds250dfx10_write_register(client, 0x3F, 0x40, 0x40);
+	ret |= ds250dfx10_write_register(client, 0x3F, 0x04, 0x0F);
+
+	// deassert cdr
+	ret |= ds250dfx10_write_register(client, 0x0A, 0x00, 0x0C);
+
+	if (!ret)
+		dev_info(&client->dev, "configured channel %u for 1G\n", channel);
+}
+
 static void ds250dfx10_config_10g(struct i2c_client *client, uint8_t channel)
 {
 	int ret = 0;
@@ -87,6 +140,18 @@ static void ds250dfx10_config_10g(struct i2c_client *client, uint8_t channel)
 	// assert cdr
 	ret |= ds250dfx10_write_register(client, 0x0A, 0x0C, 0x0C);
 
+	// disable manual data rate override
+	ret |= ds250dfx10_write_register(client, 0x60, 0x00, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x61, 0x00, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x62, 0x00, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x63, 0x00, 0xFF);
+
+	// set minimum ppm delta tolerance (reset-default)
+	ret |= ds250dfx10_write_register(client, 0x64, 0x00, 0xFF);
+
+	// disable manual divider override
+	ret |= ds250dfx10_write_register(client, 0x09, 0x00, 0x04);
+
 	// select 10.3125 rate
 	ret |= ds250dfx10_write_register(client, 0x2F, 0x00, 0xF0);
 
@@ -128,6 +193,18 @@ static void ds250dfx10_config_25g(struct i2c_client *client, uint8_t channel)
 	// assert cdr
 	ret |= ds250dfx10_write_register(client, 0x0A, 0x0C, 0x0C);
 
+	// disable manual data rate override
+	ret |= ds250dfx10_write_register(client, 0x60, 0x00, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x61, 0x00, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x62, 0x00, 0xFF);
+	ret |= ds250dfx10_write_register(client, 0x63, 0x00, 0xFF);
+
+	// set minimum ppm delta tolerance (reset-default)
+	ret |= ds250dfx10_write_register(client, 0x64, 0x00, 0xFF);
+
+	// disable manual divider override
+	ret |= ds250dfx10_write_register(client, 0x09, 0x00, 0x04);
+
 	// select 25.78125 rate
 	ret |= ds250dfx10_write_register(client, 0x2F, 0x50, 0xF0);
 
@@ -161,6 +238,9 @@ static int ds250dfx10_phy_set_mode(struct phy *phy, enum phy_mode mode, int subm
 		return -EOPNOTSUPP;
 
 	switch (submode) {
+	case PHY_INTERFACE_MODE_SGMII:
+		ds250dfx10_config_1g(priv->client, priv->channel);
+		break;
 	case PHY_INTERFACE_MODE_10GBASER:
 		ds250dfx10_config_10g(priv->client, priv->channel);
 		break;
-- 
2.43.0

