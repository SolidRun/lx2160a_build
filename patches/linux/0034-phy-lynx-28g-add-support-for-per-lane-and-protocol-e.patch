From d798df57fbe49e61b959bc7c0adfbd1f559122bb Mon Sep 17 00:00:00 2001
From: Josua Mayer <josua@solid-run.com>
Date: Fri, 21 Feb 2025 18:49:46 +0100
Subject: [PATCH 34/35] phy: lynx-28g: add support for per lane and protocol eq
 params

Add support for parsing lane- and protocol-specific equalization
parameters described in device-tree.

If not specified defaults are used and no change in behaviour is
intended.

Signed-off-by: Josua Mayer <josua@solid-run.com>
---
 drivers/phy/freescale/phy-fsl-lynx-28g.c | 156 +++++++++++++++++++++++
 1 file changed, 156 insertions(+)

diff --git a/drivers/phy/freescale/phy-fsl-lynx-28g.c b/drivers/phy/freescale/phy-fsl-lynx-28g.c
index 591aa351f1f6..e9a0c9ed0246 100644
--- a/drivers/phy/freescale/phy-fsl-lynx-28g.c
+++ b/drivers/phy/freescale/phy-fsl-lynx-28g.c
@@ -192,6 +192,23 @@ enum lynx_28g_eq_amp_red_rate {
 	LYNX_28G_EQ_AMP_RED_RATE_1P100,
 };
 
+static const char * const lynx_28g_eq_types[] = { "none", "2-tap", "3-tap" };
+
+static const char * const lynx_28g_eq_signs[] = { "negative", "positive" };
+
+static const char * const lynx_28g_eq_rates[] = {
+	"1.00", "1.04", "1.09", "1.14", "1.20", "1.26", "1.33",
+	"1.40", "1.50", "1.60", "1.71", "1.84", "2.00",
+};
+
+static const char * const lynx_28g_amp_red_rates[] = {
+	"1.000", "0.917", "0.752", "0.840", NULL, NULL, "0.667", "0.585",
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	"0.500", "0.485", "0.376", "0.420", NULL, NULL, "0.333", "0.292",
+	NULL, NULL, NULL, NULL, NULL, NULL, NULL, "0.170",
+	"1.100",
+};
+
 struct lynx_28g_priv;
 
 struct lynx_28g_eq {
@@ -734,6 +751,125 @@ static struct phy *lynx_28g_xlate(struct device *dev,
 	return phy;
 }
 
+static int helper(struct device *dev, const char *propname, int prot_idx, const char * const lut[], size_t lut_size, u32 *regval) {
+	int ret;
+	const char *val_str;
+
+	/* look-up property value at index */
+	ret = device_property_read_string_index(dev, propname, prot_idx, &val_str);
+	if (ret) {
+		dev_err(dev, "failed to get property \"%s\" index %d: %d\n", propname, prot_idx, ret);
+		return ret;
+	}
+
+	/* translate to register value by look=up table */
+	ret = match_string(lut, lut_size, val_str);
+	if (ret < 0) {
+		dev_err(dev, "invalid value \"%s\" for property \"%s\": %d\n", val_str, propname, ret);
+		return ret;
+	}
+	*regval = ret;
+
+	return 0;
+}
+
+static int lynx_28g_parse_eq_reg0(struct device *dev, u32 prot_idx, struct lynx_28g_eq *out_eqparams)
+{
+	int ret;
+	u32 val, lnatecr0;
+
+	if (!device_property_present(dev, "fsl,eq-type") &&
+	    !device_property_present(dev, "fsl,eq-preq-sign") &&
+	    !device_property_present(dev, "fsl,eq-preq-rate") &&
+	    !device_property_present(dev, "fsl,eq-post1q-sign") &&
+	    !device_property_present(dev, "fsl,eq-post1q-rate") &&
+	    !device_property_present(dev, "fsl,eq-amp-red")) {
+		/* no parameter specified, keep defaults */
+		return 0;
+	}
+
+	ret = helper(dev, "fsl,eq-type", prot_idx, lynx_28g_eq_types, ARRAY_SIZE(lynx_28g_eq_types), &val);
+	if (ret)
+		return ret;
+	lnatecr0 |= LYNX_28G_LNaTECR0_EQ_TYPE_VAL(val);
+
+	ret = helper(dev, "fsl,eq-preq-sign", prot_idx, lynx_28g_eq_signs, ARRAY_SIZE(lynx_28g_eq_signs), &val);
+	if (ret)
+		return ret;
+	lnatecr0 |= LYNX_28G_LNaTECR0_EQ_SGN_PREQ(val);
+
+	ret = helper(dev, "fsl,eq-preq-rate", prot_idx, lynx_28g_eq_rates, ARRAY_SIZE(lynx_28g_eq_rates), &val);
+	if (ret)
+		return ret;
+	lnatecr0 |= LYNX_28G_LNaTECR0_EQ_PREQ_VAL(val);
+
+	ret = helper(dev, "fsl,eq-post1q-sign", prot_idx, lynx_28g_eq_signs, ARRAY_SIZE(lynx_28g_eq_signs), &val);
+	if (ret)
+		return ret;
+	lnatecr0 |= LYNX_28G_LNaTECR0_EQ_SGN_POST1Q(val);
+
+	ret = helper(dev, "fsl,eq-post1q-rate", prot_idx, lynx_28g_eq_rates, ARRAY_SIZE(lynx_28g_eq_rates), &val);
+	if (ret)
+		return ret;
+	lnatecr0 |= LYNX_28G_LNaTECR0_EQ_POST1Q_VAL(val);
+
+	ret = helper(dev, "fsl,eq-amp-red", prot_idx, lynx_28g_amp_red_rates, ARRAY_SIZE(lynx_28g_amp_red_rates), &val);
+	if (ret)
+		return ret;
+	lnatecr0 |= LYNX_28G_LNaTECR0_EQ_AMP_RED_VAL(val);
+
+	out_eqparams->lnatecr0 = lnatecr0;
+
+	return ret;
+}
+
+static int lynx_28g_parse_eq_reg1(struct device *dev, u32 prot_idx, struct lynx_28g_eq *out_eqparams)
+{
+	int ret;
+	u32 val, lnatecr1;
+
+	if (!device_property_present(dev, "fsl,eq-adaptive")) {
+		/* no parameter specified, keep defaults */
+		return 0;
+	}
+
+	ret = of_property_read_u32_index(dev->of_node, "fsl,eq-adaptive", prot_idx, &val);
+	// TODO: add and use device_property_read_u32_index
+	if (ret)
+		return ret;
+	else if (val < 20 || val > 48)
+		return -ERANGE;
+	lnatecr1 |= LYNX_28G_LNaTECR1_EQ_ADPT_EQ(val);
+
+	out_eqparams->lnatecr1 = lnatecr1;
+
+	return ret;
+}
+
+static int lynx_28g_parse_eq_regs(struct device *dev, const char *prot_name, struct lynx_28g_eq *out_eqparams)
+{
+	int ret, prot_idx;
+
+	if (!device_property_present(dev, "fsl,eq-names"))
+		return 0;
+
+	prot_idx = device_property_match_string(dev, "fsl,eq-names", prot_name);
+	if (prot_idx == -ENODATA)
+		return 0;
+	else if (prot_idx < 0)
+		return prot_idx;
+
+	ret = lynx_28g_parse_eq_reg0(dev, prot_idx, out_eqparams);
+	if (ret)
+		return ret;
+
+	ret = lynx_28g_parse_eq_reg1(dev, prot_idx, out_eqparams);
+	if (ret)
+		return ret;
+
+	return ret;
+}
+
 static int lynx_28g_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -828,6 +964,26 @@ static int lynx_28g_probe(struct platform_device *pdev)
 			LYNX_28G_LNaTECR0_EQ_POST1Q_VAL(LYNX_28G_EQ_RATE_1P40) |
 			LYNX_28G_LNaTECR0_EQ_AMP_RED_VAL(LYNX_28G_EQ_AMP_RED_RATE_1P000);
 		lane->eq_25gbaser.lnatecr1 = LYNX_28G_LNaTECR1_EQ_ADPT_EQ(48);
+
+		/* override equalization parameters from firmware */
+		ret = lynx_28g_parse_eq_regs(&phy->dev, "sgmii", &lane->eq_sgmii);
+		if (ret)
+			return dev_err_probe(dev, ret, "failed to parse sgmii equalization parameters\n");
+
+		ret = lynx_28g_parse_eq_regs(&phy->dev, "10gbase-r", &lane->eq_10gbaser);
+		if (ret)
+			return dev_err_probe(dev, ret, "failed to parse 10gbase-r equalization parameters\n");
+
+		ret = lynx_28g_parse_eq_regs(&phy->dev, "25gbase-r", &lane->eq_25gbaser);
+		if (ret)
+			return dev_err_probe(dev, ret, "failed to parse 25gbase-r equalization parameters\n");
+
+		dev_dbg(&phy->dev, "\"%s\" eq regs lnatecr0 = %X, lnatecr1 = %X\n",
+			"sgmii", lane->eq_sgmii.lnatecr0, lane->eq_sgmii.lnatecr1);
+		dev_dbg(&phy->dev, "\"%s\" eq regs lnatecr0 = %X, lnatecr1 = %X\n",
+			"10gbase-r", lane->eq_10gbaser.lnatecr0, lane->eq_10gbaser.lnatecr1);
+		dev_dbg(&phy->dev, "\"%s\" eq regs lnatecr0 = %X, lnatecr1 = %X\n",
+			"25gbase-r", lane->eq_25gbaser.lnatecr0, lane->eq_25gbaser.lnatecr1);
 	}
 
 	dev_set_drvdata(dev, priv);
-- 
2.43.0

